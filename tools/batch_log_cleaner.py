#!/usr/bin/env python3

# Script to remove identifying information from standard mail log files
# generated by Postfix
#
# Note: Always check the output of this script before sharing it, to ensure that
#       obfuscation was successful!
#
# Note: Requires the additional script `log_cleaner.py` to be located within
#       the same path
#

# For usage, try running with --help

import argparse
import pathlib
import gzip
import tarfile
import os

parser = argparse.ArgumentParser()

parser.add_argument("--input-dir", "-i", help="Input directory")
parser.add_argument("--output-file", "-o", help="Output file")
parser.add_argument("--complete", "-c", help="Use the entire files. Ignore --lines", action="store_true")
parser.add_argument("--lines", "-l", help="Number of lines in the sample (begin and end of the files)", default=500)

args = parser.parse_args()

input_dir = args.input_dir

def mktemp():
    import tempfile
    return tempfile.mktemp(prefix="cleaner_")

def open_file(filename):
    if filename.endswith(".gz"):
        return gzip.open(filename)

    return open(filename)

def collect_samples(input_file, output_file):
    from log_cleaner import clean_line, as_string
    import collections
    from itertools import chain

    # read the first N lines from the file
    head_lines = []
    count = 0
    for line in input_file:
        if count >= args.lines:
            break

        head_lines.append(line)
        count += 1

    # keep the last N lines from the file
    tail_lines = collections.deque(maxlen=args.lines)
    for line in input_file:
        tail_lines.append(line)

    for line in chain(head_lines, tail_lines):
        cleaned_line = clean_line(line)
        output_file.write(as_string(cleaned_line))
        output_file.write("\n")

cleanup_functions = []

def clean_file(filename):
    from log_cleaner import clean_file as clean_whole_file

    temp_filename = mktemp()

    with open(temp_filename, "a") as t:
        temp_filename = t.name
        cleanup_functions.append(lambda: os.remove(temp_filename))

        with open_file(filename) as f:
            def clean_complete_file():
                def p(l):
                    t.write(l)
                    t.write("\n")

                clean_whole_file(f, p)

            clean_complete_file() if args.complete else collect_samples(f, t)

            return temp_filename

def cleanup_temp_files():
    for f in cleanup_functions:
        f()

def clean_to_temp_file(path):
    filename = path.as_posix()

    temp_filename = clean_file(filename)

    if filename.endswith(".gz"):
        temp_compressed_filename = mktemp()
        cleanup_functions.append(lambda: os.remove(temp_compressed_filename))

        with gzip.open(temp_compressed_filename, "wb") as g, open(temp_filename, "rb") as t:
            g.writelines(t)
            return temp_compressed_filename

    return temp_filename

try:
    with tarfile.open(args.output_file, "w:gz") as tar:
        for path in pathlib.Path(input_dir).rglob("mail.*"):
            if not path.is_file():
                continue

            temp_filename = clean_to_temp_file(path)

            info = tar.gettarinfo(temp_filename, path.as_posix())
            info.mtime = path.stat().st_mtime

            with open(temp_filename, "rb") as f:
                tar.addfile(info, f)
except Exception as e:
    print(f"Some error happened: {e}")
finally:
    cleanup_temp_files()
